(defparameter *fsm* (list))
(defparameter *cst* (list))
(defparameter *enc* (list))
(defparameter *encwd* 0)
(defparameter *tr* (list))
(defparameter *rst* (list))
(defparameter *switching-activity* 0)
(defparameter *at* (list))
(defparameter *nst-set* (list))
(defparameter *nst-rst* (list))
(defun report_fsm (s)
  (format s "~%") 
  (format s "fsm    : ~20A @ ~20A ~%" 
          (with-output-to-string (s1) (format s1 "~A[~A:0]"(car *fsm*) (1- *encwd*)))
          (nth 2 *rst*)
          )
  (format s "state  : ~{~A ~}~%" (reverse *cst*))
  (format s "reset  : ~20A @ ~20A ~%" (nth 0 *rst*) (nth 1 *rst*))
  (format s "transition : ~%")
  (map 'list
       (lambda (tr)
         (format s "~5A ~20A -> ~20A @ ~20A~%" (nth 3 tr) (nth 0 tr) (nth 1 tr) (nth 2 tr)))
       (reverse *tr*))
  (format s "~%") 
  *fsm*)
(defun report_fsm_dot (s)
  (format s "digraph {~%")
  ;(format s "  splines=ortho;~%")
  (format s "  label=\"~A[~D:0]\";~%" (car *fsm*) (1- *encwd*))
  (format s "  NIL [label=\"*\"];~%")
  (map 'list
       (lambda (cst)
         (if cst
           (format s "  ~A [label=\"~A~%~b\"];~%" cst cst (nth 1 (assoc cst *enc* :test #'equalp)))))
       (reverse *cst*))
  (map 'list
       (lambda (tr)
         (if (nth 0 tr)
           (format s "  ~A -> ~A [label=\"~A~%~A\"];~%" (nth 0 tr) (nth 1 tr) (if (nth 2 tr) (nth 2 tr) (nth 2 *rst*)) (nth 3 tr))))
       (reverse *tr*))
  (format s " NIL -> ~A [label=\"~A~%~A\"];~%" (nth 0 *rst*) (nth 1 *rst*) 1)
  (format s "}~%")
  )
(defun write_dot (file)
  (with-open-file
    (s file
       :direction :output
       :if-does-not-exist :create
       :if-exists :supersede
       )
    (report_fsm_dot s)))
(defun show_cfg (&optional png)
  (write_dot (string+ "./"(sxhash *fsm*)".dot"))
  (exec 
    t "dot" "-Tpng" 
    (string+ "./"(sxhash *fsm*)".dot") 
    "-o" 
    (if png png (string+ "./"(sxhash *fsm*)".png"))
    )
  (exec 
    t "feh" 
    (if png png (string+ "./"(sxhash *fsm*)".png"))
    )
  )
(defun set_fsm (&key states name outputs init reset update)
  (setf *fsm* (append (list name) (if outputs outputs (list))))
  (setf *rst* (list init reset update))
  (setf *cst* (if states states (list)))
  (setf *at* (list))
  name)
(defun set_transition (&key from to at weight)
  (let ((cst (if from from nil))
        (at (if at at nil))
        (w (if weight weight 1)))
    (if (and from (not (member from *cst*))) (push from *cst*))
    (if (and to (not (member to *cst*))) (push to *cst*))
    (push (list cst to at w) *tr*)
    (if (and
          at
          (not(member at *at* :test #'equalp))
          )
      (push at *at*))
    )
  to)
(defun nextnodes (node)
  (let ((r (list)))
    (map 'list
         (lambda (tr)
           (if (and
                 (equalp (nth 0 tr) node)
                 (nth 1 tr))
             (push (nth 1 tr) r)))
         *tr*)
    (remove-duplicates r :test #'equalp)))
(defparameter *dfs* (list))
(defun dfs-1 (v f)
  (funcall f v)
  (push v *dfs*)
  (map 'list
       (lambda (w)
         (if (not(member w *dfs* :test #'equalp))
           (dfs-1 w f)))
       (nextnodes v))
  v)
(defun dfs (v f)
  (setf *dfs* (list))
  (dfs-1 v f))
(defparameter *bfs* (list))
(defun bfs-1 (v0 f)
  (let ((q (list v0)))
    (funcall f v0)
    (push v0 *bfs*)
    (do ((v v0 (pop q)))
      ((not q))
      (map 'list
           (lambda (w)
             (if (not(member w *bfs* :test #'equalp))
               (let ()
                 (funcall f w)
                 (push w *bfs*)
                 (push w q)
                 )))
           (nextnodes v)))))
(defun bfs (v f)
  (setf *bfs* (list))
  (bfs-1 v f))
(defun switching-activity (cst nst weight)
  (if (and
        (assoc cst *enc* :test #'equalp)
        (nth 1 (assoc cst *enc* :test #'equalp))
        (numberp (nth 1 (assoc cst *enc* :test #'equalp)))
        (assoc nst *enc* :test #'equalp)
        (nth 1 (assoc nst *enc* :test #'equalp))
        (numberp (nth 1 (assoc nst *enc* :test #'equalp)))
        )
  (let*((e0 (nth 1 (assoc cst *enc* :test #'equalp)))
        (e1 (nth 1 (assoc nst *enc* :test #'equalp)))
        (e (logxor e0 e1))
        (sa *switching-activity*))
    (dotimes (k *encwd*)
      (if (/= 0 (logand (ash 1 k) e))
        (incf *switching-activity* weight)))
    (format t "switching-activity : ~20A ~20b -> ~20A ~20b, +~A~%" cst e0 nst e1 (float (- *switching-activity* sa)))
    )))
(defun append-default ()
  (let ((l (list)))
    (map 'list
         (lambda (e)
           (setf l (append l (cdr e))))
         *enc*)
    (dotimes (k (ash 1 *encwd*))
      (if (not(member k l))
        (let ((cst (with-output-to-string (s) (format s "others_~b" k)))
              (nst nil))
          (push (list cst k) *enc*)
          (map 'list
               (lambda (tr)
                 (if (equalp nil (nth 0 tr))
                   (setf nst (nth 1 tr))))
               *tr*)
          (set_transition :from cst :to nst)
          )))
    #|(delete-if
      #'(lambda (tr)
          (if (equalp nil (nth 1 tr))
            t nil))
      *tr*)|#
    ))
(defun autoenc (&optional f)
  (if f
    (let ()
      (format t "auto encode with ~A~%" f)
      (setf *enc* (list))
      (setf *encwd* 0)
      (let ((cnt 0))
        (funcall
          f
          (nth 0 *rst*)
          #'(lambda (v)
              (let ((e (logxor cnt (ash cnt -1))))
                (do ((emax (ash 1 *encwd*) (ash 1 *encwd*)))
                  ((> emax e))
                  (incf *encwd*))
                (format t "~20A~20b~%" v e)
                (push (list v e) *enc*)
                (incf cnt))))
        (setf *switching-activity* 0)
        (map 'list
             (lambda (tr)
               (switching-activity (nth 0 tr) (nth 1 tr) (nth 3 tr)))
             *tr*)
        (format t "switching-activity : ~D~%" (float *switching-activity*))
        *switching-activity*))
    (let ((sa (list))
          (fsm (list))
          (cst (list))
          (enc (list))
          (encwd (list))
          (tr (list))
          (rst (list)))
      (push (autoenc #'dfs) sa)
      (append-default)
      (push *fsm* fsm)
      (push *cst* cst)
      (push *enc* enc)
      (push *encwd* encwd)
      (push *tr* tr)
      (push *rst* rst)
      (if (> (autoenc #'bfs) (car sa))
        (let ()
          (append-default)
          (format t "select ~A~%" #'dfs)
          (setf *fsm* (pop fsm))
          (setf *cst* (pop cst))
          (setf *enc* (pop enc))
          (setf *encwd* (pop encwd))
          (setf *tr* (pop tr))
          (setf *rst* (pop rst))
          )
        (format t "select ~A~%" #'bfs)
        )
      )))
(defun reset_probablity ()
  (map 'list
       (lambda (cst)
         (let ((nsts (nextnodes cst)))
           (map 'list
                (lambda (nst)
                  (let ((v (/ 1 (length nsts))))
                    (setf 
                      *tr* 
                      (map 'list 
                           (lambda (tr) 
                             (let ((tr1 tr))
                               (if (equalp (nth 0 tr1) cst)
                                 (if (equalp (nth 1 tr1) nst)
                                   (setf (nth 3 tr1) v)))
                             tr1))
                           *tr*))))
                nsts)))
       *cst*))
(defun synthesis_set_rst_fsm ()
  (setf *nst-set* (make-list *encwd* :initial-element (list)))
  (setf *nst-rst* (make-list *encwd* :initial-element (list)))
  (dotimes (k (length *tr*))
    (let*((tr (nth k *tr*))
          (cst (nth 0 tr))
          (nst (nth 1 tr)))
      (if (and
            (assoc cst *enc* :test #'equalp)
            (numberp (nth 1 (assoc cst *enc* :test #'equalp)))
            (assoc nst *enc* :test #'equalp)
            (numberp (nth 1 (assoc nst *enc* :test #'equalp)))
            )
        (let ((ce (nth 1 (assoc cst *enc* :test #'equalp)))
              (ne (nth 1 (assoc nst *enc* :test #'equalp))))
          (format t "~5A : ~20A(~10b) -> ~20A(~10b) @ ~A ~%" k cst ce nst ne (nth 2 tr))
          (dotimes (j *encwd*)
            (cond
              ((and (= 0 (logand (ash 1 j) ce)) (/= 0 (logand (ash 1 j) ne))) (push k (nth j *nst-set*)))
              ((and (= 0 (logand (ash 1 j) ne)) (/= 0 (logand (ash 1 j) ce))) (push k (nth j *nst-rst*)))
              ))
          ))
      ))
  ;(format t "*nst-set* : ~{~A ~}~%" *nst-set*)
  ;(format t "*nst-rst* : ~{~A ~}~%" *nst-rst*)
  )
(defun print_verilog_set_rst_fsm (s)
  (format s "~%")
  (format s "module FSM_CORE_~X~%" (sxhash *fsm*))
  (format s "(~%")
  (format s "  output reg [~3d:0] CST  , ~%" (1- *encwd*))
  (format s "   input     [~3d:0] AT   , ~%" (1-(length *at*)))
  (format s "   input             RESET, HALT ~%")
  (format s ");~%")
  (format s "localparam [~3d:0] INIT = ~d'h~x;~%" (1- *encwd*) *encwd* (nth 1 (assoc (nth 0 *rst*) *enc* :test #'equalp)))
  (dotimes (k *encwd*)
    (let ((pu (list))
          (pd (list)))
      (map 'list
           (lambda (j)
             (let*((tr (nth j *tr*))
                   (cst (nth 0 tr))
                   (cstnum (nth 1 (assoc cst *enc* :test #'equalp)))
                   (at (nth 2 tr))
                   (atnum (position at *at* :test #'equalp)))
               (push 
                 (with-output-to-string (s1)
                   (if (numberp atnum)
                     (format s1 "&{CST=='h~x,AT[~d]}" cstnum atnum)
                     (format s1 "(CST=='h~x)" cstnum)
                     )
                   )
                 pu)))
           (nth k *nst-set*))
      (format s "wire SET_~d = |{~{~A~^,~}};~%" k pu)
      (map 'list
           (lambda (j)
             (let*((tr (nth j *tr*))
                   (cst (nth 0 tr))
                   (cstnum (nth 1 (assoc cst *enc* :test #'equalp)))
                   (at (nth 2 tr))
                   (atnum (position at *at* :test #'equalp)))
               (push 
                 (with-output-to-string (s1)
                   (if (numberp atnum)
                     (format s1 "&{CST=='h~x,AT[~d]}" cstnum atnum)
                     (format s1 "(CST=='h~x)" cstnum)
                     )
                   )
                 pd)))
           (nth k *nst-rst*))
      (format s "wire RST_~d = |{~{~A~^,~}};~%" k pd)
      (format s "wire NST_SET_~d = !HALT && (INIT[~d] ? RST_~d : SET_~d);~%" k k k k)
      (format s "wire NST_RST_~d = !HALT && (RESET || (INIT[~d] ? SET_~d : RST_~d));~%" k k k k)
      (format s "always@(posedge NST_RST_~d or posedge NST_SET_~d) if(NST_RST_~d) `CK2Q CST[~d] <= INIT[~d]; else `CK2Q CST[~d] <= !(INIT[~d]);~%" k k k k k k k)
      ))
  (format s "endmodule~%")
  (format s "~%")
  )
(defun print_verilog_fsm_bist (s)
  (format s "~%")
  (format s "module FSM_BIST_~X~%" (sxhash *fsm*))
  (format s "(~%")
  (format s "  output reg         PASS , ~%")
  (format s "  output             DONE , ~%")
  (format s "   input     [~3d:0] CST  , ~%" (1- *encwd*))
  (format s "  output reg [~3d:0] AT   , ~%" (1-(length *at*)))
  (format s "  output             HALT , ~%")
  (format s "   input             TEST , CLK  ~%")
  (format s ");~%")
  (format s "reg [~3d:0] CST_1;~%" (1- *encwd*))
  (format s "integer k;~%")
  (format s "always@(negedge TEST or posedge CLK) begin~%")
  (format s "  if(!TEST) begin~%")
  (format s "    AT <= ~d'h1;~%" (length *at*))
  (format s "  end~%")
  (format s "  else if(!DONE) begin~%")
  (format s "    AT <= (AT<<1) | (AT[~d]^AT[~d]);~%" (- (length *at*) 1) (- (length *at*) 2))
  (format s "    CST_1 <= CST;~%")
  (format s "  end~%")
  (format s "end~%")
  (format s "always@(negedge TEST or posedge CLK) begin~%")
  (format s "  if(!TEST) begin~%")
  (format s "    PASS <= 1'b1;~%")
  (format s "  end~%")
  (format s "  else if(!DONE) begin~%")
  (format s "    if(PASS) begin~%")
  (map 'list
       (lambda (tr)
         (let*((cst (nth 0 tr))
               (nst (nth 1 tr))
               (cen (nth 1 (assoc cst *enc* :test #'equalp)))
               (nen (nth 1 (assoc nst *enc* :test #'equalp)))
               (at (nth 2 tr))
               (atnum (position at *at* :test #'equalp)))
           (if (and
                 (numberp cen)
                 (numberp nen)
                 (numberp atnum)
                 (= (length (nextnodes cst)) 1)
                 )
             (let ()
               (format s "      if((CST_1=='h~x) && (CST!='h~x) && AT[~d]) PASS <= 1'b0;~%" cen nen atnum)
               ))))
       *tr*)
  (format s "    end~%")
  (format s "  end~%")
  (format s "end~%")
  (format s "assign HALT = CST != CST_1;~%")
  (format s "assign DONE = &AT;~%")
  (format s "endmodule~%")
  (format s "~%")
  )
(defun print_verilog_set_rst_fsm_bist_tb (s)
  (format s "~%")
  (format s "`ifdef SIM~%")
  (format s "module FSM_BIST_~X_tb;~%" (sxhash *fsm*))
  (format s "~%")
  (format s "  wire [~3d:0] CST  ; ~%" (1- *encwd*))
  (format s "  wire [~3d:0] AT   ; ~%" (1-(length *at*)))
  (format s "   reg         RESET; ~%")
  (format s "  wire         HALT ; ~%")
  (format s "  wire         PASS ; ~%")
  (format s "  wire         DONE ; ~%")
  (format s "   reg         TEST , CLK ;~%")
  (format s "~%")
  (format s "FSM_CORE_~X core~%" (sxhash *fsm*))
  (format s "(~%")
  (format s "  CST  , ~%")
  (format s "  AT   , ~%")
  (format s "  RESET, HALT ~%")
  (format s ");~%")
  (format s "~%")
  (format s "FSM_BIST_~X bist~%" (sxhash *fsm*))
  (format s "(~%")
  (format s "  PASS , ~%")
  (format s "  DONE , ~%")
  (format s "  CST  , ~%")
  (format s "  AT   , ~%")
  (format s "  HALT , ~%")
  (format s "  TEST , CLK  ~%")
  (format s ");~%")
  (format s "~%")
  (format s "initial CLK = 1'b0;~%")
  (format s "always #10 CLK = ~cCLK;~%" #\~)
  (format s "~%")
  (format s "initial begin~%")
  (format s "`ifdef FST~%")
  (format s "$dumpfile(\"FSM_BIST_~X_tb.fst\");~%" (sxhash *fsm*))
  (format s "$dumpvars(0,FSM_BIST_~X_tb);~%" (sxhash *fsm*))
  (format s "`endif~%")
  (format s "`ifdef FSDB~%")
  (format s "$fsdbDumpfile(\"FSM_BIST_~X_tb.fsdb\");~%" (sxhash *fsm*))
  (format s "$fsdbDumpvars(0,FSM_BIST_~X_tb);~%" (sxhash *fsm*))
  (format s "`endif~%")
  ;(format s "repeat(3) begin~%")
  (format s "RESET = 1'b1;~%")
  (format s "TEST = 1'b0;~%")
  (format s "repeat(2) @(posedge CLK);~%")
  (format s "RESET = 1'b0;~%")
  (format s "repeat(2) @(posedge CLK);~%")
  (format s "TEST = 1'b1;~%")
  (format s "$write(\"%t: TEST\\n\", $time);~%")
  (format s "while(!DONE) @(posedge CLK);~%")
  (format s "repeat(2) @(posedge CLK);~%")
  (format s "if(PASS) $write(\"%t: PASS\\n\", $time);~%")
  (format s "else $write(\"%t: FAIL\\n\", $time);~%")
  (format s "repeat(2) @(posedge CLK);~%")
  ;(format s "end~%")
  (format s "$finish;~%")
  (format s "end~%")
  (format s "endmodule~%")
  (format s "`endif~%")
  (format s "~%")
  )
(defun print_verilog_set_rst_fsm_te (s)
  (format s "module FSM_TE_~X~%" (sxhash *fsm*))
  (format s "(~%")
  (format s "  output         PASS , ~%")
  (format s "  output         DONE , ~%")
  (format s "   input         TEST, CLK , ~%")
  (format s "  output [~3d:0] CST  , ~%" (1- *encwd*))
  (format s "   input [~3d:0] AT   , ~%" (1-(length *at*)))
  (format s "   input         RESET, HALT~%")
  (format s ");~%")
  (format s "~%")
  (format s "wire [~3d:0] TEST_AT  ;~%" (1-(length *at*)))
  (format s "wire         TEST_HALT;~%")
  (format s "~%")
  (format s "FSM_BIST_~X u_bist_teston_dontscan~%" (sxhash *fsm*))
  (format s "(~%")
  (format s "  PASS , ~%")
  (format s "  DONE , ~%")
  (format s "  CST  , ~%")
  (format s "  TEST_AT  , ~%")
  (format s "  TEST_HALT, ~%")
  (format s "  TEST , CLK  ~%")
  (format s ");~%")
  (format s "~%")
  (format s "FSM_CORE_~X u_core_dontscan~%" (sxhash *fsm*))
  (format s "(~%")
  (format s "  CST  , ~%")
  (format s "  (TEST ? TEST_AT : AT)   , ~%")
  (format s "  RESET, (TEST ? TEST_HALT : HALT) ~%")
  (format s ");~%")
  (format s "~%")
  (format s "endmodule~%")
  )
(defun print_verilog_set_rst_fsm_te_tb (s)
  (format s "~%")
  (format s "`ifdef SIM~%")
  (format s "module FSM_TE_~X_tb;~%" (sxhash *fsm*))
  (format s "~%")
  (format s "  wire [~3d:0] CST  ; ~%" (1- *encwd*))
  (format s "  wire [~3d:0] AT   ; ~%" (1-(length *at*)))
  (format s "   reg         RESET; ~%")
  (format s "   reg         HALT ; ~%")
  (format s "  wire         PASS ; ~%")
  (format s "  wire         DONE ; ~%")
  (format s "   reg         TEST , CLK ;~%")
  (format s "~%")
  (format s "FSM_TE_~X fsm_te~%" (sxhash *fsm*))
  (format s "(~%")
  (format s "  PASS , ~%")
  (format s "  DONE , ~%")
  (format s "  TEST , CLK,  ~%")
  (format s "  CST  , ~%")
  (format s "  AT   , ~%")
  (format s "  RESET, HALT ~%")
  (format s ");~%")
  (format s "~%")
  (format s "initial CLK = 1'b0;~%")
  (format s "always #10 CLK = ~cCLK;~%" #\~)
  (format s "~%")
  (format s "initial begin~%")
  (format s "`ifdef FST~%")
  (format s "$dumpfile(\"FSM_TE_~X_tb.fst\");~%" (sxhash *fsm*))
  (format s "$dumpvars(0,FSM_TE_~X_tb);~%" (sxhash *fsm*))
  (format s "`endif~%")
  (format s "`ifdef FSDB~%")
  (format s "$fsdbDumpfile(\"FSM_TE_~X_tb.fsdb\");~%" (sxhash *fsm*))
  (format s "$fsdbDumpvars(0,FSM_TE_~X_tb);~%" (sxhash *fsm*))
  (format s "`endif~%")
  ;(format s "repeat(3) begin~%")
  (format s "RESET = 1'b1;~%")
  (format s "HALT = 1'b0;~%")
  (format s "TEST = 1'b0;~%")
  (format s "repeat(2) @(posedge CLK);~%")
  (format s "RESET = 1'b0;~%")
  (format s "repeat(2) @(posedge CLK);~%")
  (format s "TEST = 1'b1;~%")
  (format s "$write(\"%t: TEST\\n\", $time);~%")
  (format s "while(!DONE) @(posedge CLK);~%")
  (format s "repeat(2) @(posedge CLK);~%")
  (format s "if(PASS) $write(\"%t: PASS\\n\", $time);~%")
  (format s "else $write(\"%t: FAIL\\n\", $time);~%")
  (format s "repeat(2) @(posedge CLK);~%")
  ;(format s "end~%")
  (format s "$finish;~%")
  (format s "end~%")
  (format s "endmodule~%")
  (format s "`endif~%")
  (format s "~%")
  )
(defun write_verilog_set_rst_fsm (file)
  (with-open-file
    (s file
       :direction :output
       :if-does-not-exist :create
       :if-exists :supersede
       )    
    (format s "`timescale 1ns/1ps~%")
    (format s "`ifndef CK2Q~%")
    (format s "`define CK2Q #1~%")
    (format s "`endif~%")
    (print_verilog_set_rst_fsm s)
    (print_verilog_fsm_bist s)
    (print_verilog_set_rst_fsm_bist_tb s)
    (print_verilog_set_rst_fsm_te s)
    (print_verilog_set_rst_fsm_te_tb s)
    ))
